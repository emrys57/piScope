/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/regression/dist/regression.js":
/*!****************************************************!*\
  !*** ./node_modules/regression/dist/regression.js ***!
  \****************************************************/
/***/ (function(module, exports) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(this, function (module) {\n  'use strict';\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  var _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  function _toConsumableArray(arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n        arr2[i] = arr[i];\n      }\n\n      return arr2;\n    } else {\n      return Array.from(arr);\n    }\n  }\n\n  var DEFAULT_OPTIONS = { order: 2, precision: 2, period: null };\n\n  /**\n  * Determine the coefficient of determination (r^2) of a fit from the observations\n  * and predictions.\n  *\n  * @param {Array<Array<number>>} data - Pairs of observed x-y values\n  * @param {Array<Array<number>>} results - Pairs of observed predicted x-y values\n  *\n  * @return {number} - The r^2 value, or NaN if one cannot be calculated.\n  */\n  function determinationCoefficient(data, results) {\n    var predictions = [];\n    var observations = [];\n\n    data.forEach(function (d, i) {\n      if (d[1] !== null) {\n        observations.push(d);\n        predictions.push(results[i]);\n      }\n    });\n\n    var sum = observations.reduce(function (a, observation) {\n      return a + observation[1];\n    }, 0);\n    var mean = sum / observations.length;\n\n    var ssyy = observations.reduce(function (a, observation) {\n      var difference = observation[1] - mean;\n      return a + difference * difference;\n    }, 0);\n\n    var sse = observations.reduce(function (accum, observation, index) {\n      var prediction = predictions[index];\n      var residual = observation[1] - prediction[1];\n      return accum + residual * residual;\n    }, 0);\n\n    return 1 - sse / ssyy;\n  }\n\n  /**\n  * Determine the solution of a system of linear equations A * x = b using\n  * Gaussian elimination.\n  *\n  * @param {Array<Array<number>>} input - A 2-d matrix of data in row-major form [ A | b ]\n  * @param {number} order - How many degrees to solve for\n  *\n  * @return {Array<number>} - Vector of normalized solution coefficients matrix (x)\n  */\n  function gaussianElimination(input, order) {\n    var matrix = input;\n    var n = input.length - 1;\n    var coefficients = [order];\n\n    for (var i = 0; i < n; i++) {\n      var maxrow = i;\n      for (var j = i + 1; j < n; j++) {\n        if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][maxrow])) {\n          maxrow = j;\n        }\n      }\n\n      for (var k = i; k < n + 1; k++) {\n        var tmp = matrix[k][i];\n        matrix[k][i] = matrix[k][maxrow];\n        matrix[k][maxrow] = tmp;\n      }\n\n      for (var _j = i + 1; _j < n; _j++) {\n        for (var _k = n; _k >= i; _k--) {\n          matrix[_k][_j] -= matrix[_k][i] * matrix[i][_j] / matrix[i][i];\n        }\n      }\n    }\n\n    for (var _j2 = n - 1; _j2 >= 0; _j2--) {\n      var total = 0;\n      for (var _k2 = _j2 + 1; _k2 < n; _k2++) {\n        total += matrix[_k2][_j2] * coefficients[_k2];\n      }\n\n      coefficients[_j2] = (matrix[n][_j2] - total) / matrix[_j2][_j2];\n    }\n\n    return coefficients;\n  }\n\n  /**\n  * Round a number to a precision, specificed in number of decimal places\n  *\n  * @param {number} number - The number to round\n  * @param {number} precision - The number of decimal places to round to:\n  *                             > 0 means decimals, < 0 means powers of 10\n  *\n  *\n  * @return {numbr} - The number, rounded\n  */\n  function round(number, precision) {\n    var factor = Math.pow(10, precision);\n    return Math.round(number * factor) / factor;\n  }\n\n  /**\n  * The set of all fitting methods\n  *\n  * @namespace\n  */\n  var methods = {\n    linear: function linear(data, options) {\n      var sum = [0, 0, 0, 0, 0];\n      var len = 0;\n\n      for (var n = 0; n < data.length; n++) {\n        if (data[n][1] !== null) {\n          len++;\n          sum[0] += data[n][0];\n          sum[1] += data[n][1];\n          sum[2] += data[n][0] * data[n][0];\n          sum[3] += data[n][0] * data[n][1];\n          sum[4] += data[n][1] * data[n][1];\n        }\n      }\n\n      var run = len * sum[2] - sum[0] * sum[0];\n      var rise = len * sum[3] - sum[0] * sum[1];\n      var gradient = run === 0 ? 0 : round(rise / run, options.precision);\n      var intercept = round(sum[1] / len - gradient * sum[0] / len, options.precision);\n\n      var predict = function predict(x) {\n        return [round(x, options.precision), round(gradient * x + intercept, options.precision)];\n      };\n\n      var points = data.map(function (point) {\n        return predict(point[0]);\n      });\n\n      return {\n        points: points,\n        predict: predict,\n        equation: [gradient, intercept],\n        r2: round(determinationCoefficient(data, points), options.precision),\n        string: intercept === 0 ? 'y = ' + gradient + 'x' : 'y = ' + gradient + 'x + ' + intercept\n      };\n    },\n    exponential: function exponential(data, options) {\n      var sum = [0, 0, 0, 0, 0, 0];\n\n      for (var n = 0; n < data.length; n++) {\n        if (data[n][1] !== null) {\n          sum[0] += data[n][0];\n          sum[1] += data[n][1];\n          sum[2] += data[n][0] * data[n][0] * data[n][1];\n          sum[3] += data[n][1] * Math.log(data[n][1]);\n          sum[4] += data[n][0] * data[n][1] * Math.log(data[n][1]);\n          sum[5] += data[n][0] * data[n][1];\n        }\n      }\n\n      var denominator = sum[1] * sum[2] - sum[5] * sum[5];\n      var a = Math.exp((sum[2] * sum[3] - sum[5] * sum[4]) / denominator);\n      var b = (sum[1] * sum[4] - sum[5] * sum[3]) / denominator;\n      var coeffA = round(a, options.precision);\n      var coeffB = round(b, options.precision);\n      var predict = function predict(x) {\n        return [round(x, options.precision), round(coeffA * Math.exp(coeffB * x), options.precision)];\n      };\n\n      var points = data.map(function (point) {\n        return predict(point[0]);\n      });\n\n      return {\n        points: points,\n        predict: predict,\n        equation: [coeffA, coeffB],\n        string: 'y = ' + coeffA + 'e^(' + coeffB + 'x)',\n        r2: round(determinationCoefficient(data, points), options.precision)\n      };\n    },\n    logarithmic: function logarithmic(data, options) {\n      var sum = [0, 0, 0, 0];\n      var len = data.length;\n\n      for (var n = 0; n < len; n++) {\n        if (data[n][1] !== null) {\n          sum[0] += Math.log(data[n][0]);\n          sum[1] += data[n][1] * Math.log(data[n][0]);\n          sum[2] += data[n][1];\n          sum[3] += Math.pow(Math.log(data[n][0]), 2);\n        }\n      }\n\n      var a = (len * sum[1] - sum[2] * sum[0]) / (len * sum[3] - sum[0] * sum[0]);\n      var coeffB = round(a, options.precision);\n      var coeffA = round((sum[2] - coeffB * sum[0]) / len, options.precision);\n\n      var predict = function predict(x) {\n        return [round(x, options.precision), round(round(coeffA + coeffB * Math.log(x), options.precision), options.precision)];\n      };\n\n      var points = data.map(function (point) {\n        return predict(point[0]);\n      });\n\n      return {\n        points: points,\n        predict: predict,\n        equation: [coeffA, coeffB],\n        string: 'y = ' + coeffA + ' + ' + coeffB + ' ln(x)',\n        r2: round(determinationCoefficient(data, points), options.precision)\n      };\n    },\n    power: function power(data, options) {\n      var sum = [0, 0, 0, 0, 0];\n      var len = data.length;\n\n      for (var n = 0; n < len; n++) {\n        if (data[n][1] !== null) {\n          sum[0] += Math.log(data[n][0]);\n          sum[1] += Math.log(data[n][1]) * Math.log(data[n][0]);\n          sum[2] += Math.log(data[n][1]);\n          sum[3] += Math.pow(Math.log(data[n][0]), 2);\n        }\n      }\n\n      var b = (len * sum[1] - sum[0] * sum[2]) / (len * sum[3] - Math.pow(sum[0], 2));\n      var a = (sum[2] - b * sum[0]) / len;\n      var coeffA = round(Math.exp(a), options.precision);\n      var coeffB = round(b, options.precision);\n\n      var predict = function predict(x) {\n        return [round(x, options.precision), round(round(coeffA * Math.pow(x, coeffB), options.precision), options.precision)];\n      };\n\n      var points = data.map(function (point) {\n        return predict(point[0]);\n      });\n\n      return {\n        points: points,\n        predict: predict,\n        equation: [coeffA, coeffB],\n        string: 'y = ' + coeffA + 'x^' + coeffB,\n        r2: round(determinationCoefficient(data, points), options.precision)\n      };\n    },\n    polynomial: function polynomial(data, options) {\n      var lhs = [];\n      var rhs = [];\n      var a = 0;\n      var b = 0;\n      var len = data.length;\n      var k = options.order + 1;\n\n      for (var i = 0; i < k; i++) {\n        for (var l = 0; l < len; l++) {\n          if (data[l][1] !== null) {\n            a += Math.pow(data[l][0], i) * data[l][1];\n          }\n        }\n\n        lhs.push(a);\n        a = 0;\n\n        var c = [];\n        for (var j = 0; j < k; j++) {\n          for (var _l = 0; _l < len; _l++) {\n            if (data[_l][1] !== null) {\n              b += Math.pow(data[_l][0], i + j);\n            }\n          }\n          c.push(b);\n          b = 0;\n        }\n        rhs.push(c);\n      }\n      rhs.push(lhs);\n\n      var coefficients = gaussianElimination(rhs, k).map(function (v) {\n        return round(v, options.precision);\n      });\n\n      var predict = function predict(x) {\n        return [round(x, options.precision), round(coefficients.reduce(function (sum, coeff, power) {\n          return sum + coeff * Math.pow(x, power);\n        }, 0), options.precision)];\n      };\n\n      var points = data.map(function (point) {\n        return predict(point[0]);\n      });\n\n      var string = 'y = ';\n      for (var _i = coefficients.length - 1; _i >= 0; _i--) {\n        if (_i > 1) {\n          string += coefficients[_i] + 'x^' + _i + ' + ';\n        } else if (_i === 1) {\n          string += coefficients[_i] + 'x + ';\n        } else {\n          string += coefficients[_i];\n        }\n      }\n\n      return {\n        string: string,\n        points: points,\n        predict: predict,\n        equation: [].concat(_toConsumableArray(coefficients)).reverse(),\n        r2: round(determinationCoefficient(data, points), options.precision)\n      };\n    }\n  };\n\n  function createWrapper() {\n    var reduce = function reduce(accumulator, name) {\n      return _extends({\n        _round: round\n      }, accumulator, _defineProperty({}, name, function (data, supplied) {\n        return methods[name](data, _extends({}, DEFAULT_OPTIONS, supplied));\n      }));\n    };\n\n    return Object.keys(methods).reduce(reduce, {});\n  }\n\n  module.exports = createWrapper();\n});\n\n\n//# sourceURL=webpack://piscope/./node_modules/regression/dist/regression.js?");

/***/ }),

/***/ "./node_modules/smoothie/smoothie.js":
/*!*******************************************!*\
  !*** ./node_modules/smoothie/smoothie.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval(";(function(exports) {\r\n\r\n/**\r\n * @license\r\n * MIT License:\r\n *\r\n * Copyright (c) 2010-2013, Joe Walnes\r\n *               2013-2018, Drew Noakes\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n */\r\n\r\n/**\r\n * Smoothie Charts - http://smoothiecharts.org/\r\n * (c) 2010-2013, Joe Walnes\r\n *     2013-2018, Drew Noakes\r\n *\r\n * v1.0: Main charting library, by Joe Walnes\r\n * v1.1: Auto scaling of axis, by Neil Dunn\r\n * v1.2: fps (frames per second) option, by Mathias Petterson\r\n * v1.3: Fix for divide by zero, by Paul Nikitochkin\r\n * v1.4: Set minimum, top-scale padding, remove timeseries, add optional timer to reset bounds, by Kelley Reynolds\r\n * v1.5: Set default frames per second to 50... smoother.\r\n *       .start(), .stop() methods for conserving CPU, by Dmitry Vyal\r\n *       options.interpolation = 'bezier' or 'line', by Dmitry Vyal\r\n *       options.maxValue to fix scale, by Dmitry Vyal\r\n * v1.6: minValue/maxValue will always get converted to floats, by Przemek Matylla\r\n * v1.7: options.grid.fillStyle may be a transparent color, by Dmitry A. Shashkin\r\n *       Smooth rescaling, by Kostas Michalopoulos\r\n * v1.8: Set max length to customize number of live points in the dataset with options.maxDataSetLength, by Krishna Narni\r\n * v1.9: Display timestamps along the bottom, by Nick and Stev-io\r\n *       (https://groups.google.com/forum/?fromgroups#!topic/smoothie-charts/-Ywse8FCpKI%5B1-25%5D)\r\n *       Refactored by Krishna Narni, to support timestamp formatting function\r\n * v1.10: Switch to requestAnimationFrame, removed the now obsoleted options.fps, by Gergely Imreh\r\n * v1.11: options.grid.sharpLines option added, by @drewnoakes\r\n *        Addressed warning seen in Firefox when seriesOption.fillStyle undefined, by @drewnoakes\r\n * v1.12: Support for horizontalLines added, by @drewnoakes\r\n *        Support for yRangeFunction callback added, by @drewnoakes\r\n * v1.13: Fixed typo (#32), by @alnikitich\r\n * v1.14: Timer cleared when last TimeSeries removed (#23), by @davidgaleano\r\n *        Fixed diagonal line on chart at start/end of data stream, by @drewnoakes\r\n * v1.15: Support for npm package (#18), by @dominictarr\r\n *        Fixed broken removeTimeSeries function (#24) by @davidgaleano\r\n *        Minor performance and tidying, by @drewnoakes\r\n * v1.16: Bug fix introduced in v1.14 relating to timer creation/clearance (#23), by @drewnoakes\r\n *        TimeSeries.append now deals with out-of-order timestamps, and can merge duplicates, by @zacwitte (#12)\r\n *        Documentation and some local variable renaming for clarity, by @drewnoakes\r\n * v1.17: Allow control over font size (#10), by @drewnoakes\r\n *        Timestamp text won't overlap, by @drewnoakes\r\n * v1.18: Allow control of max/min label precision, by @drewnoakes\r\n *        Added 'borderVisible' chart option, by @drewnoakes\r\n *        Allow drawing series with fill but no stroke (line), by @drewnoakes\r\n * v1.19: Avoid unnecessary repaints, and fixed flicker in old browsers having multiple charts in document (#40), by @asbai\r\n * v1.20: Add SmoothieChart.getTimeSeriesOptions and SmoothieChart.bringToFront functions, by @drewnoakes\r\n * v1.21: Add 'step' interpolation mode, by @drewnoakes\r\n * v1.22: Add support for different pixel ratios. Also add optional y limit formatters, by @copacetic\r\n * v1.23: Fix bug introduced in v1.22 (#44), by @drewnoakes\r\n * v1.24: Fix bug introduced in v1.23, re-adding parseFloat to y-axis formatter defaults, by @siggy_sf\r\n * v1.25: Fix bug seen when adding a data point to TimeSeries which is older than the current data, by @Nking92\r\n *        Draw time labels on top of series, by @comolosabia\r\n *        Add TimeSeries.clear function, by @drewnoakes\r\n * v1.26: Add support for resizing on high device pixel ratio screens, by @copacetic\r\n * v1.27: Fix bug introduced in v1.26 for non whole number devicePixelRatio values, by @zmbush\r\n * v1.28: Add 'minValueScale' option, by @megawac\r\n *        Fix 'labelPos' for different size of 'minValueString' 'maxValueString', by @henryn\r\n * v1.29: Support responsive sizing, by @drewnoakes\r\n * v1.29.1: Include types in package, and make property optional, by @TrentHouliston\r\n * v1.30: Fix inverted logic in devicePixelRatio support, by @scanlime\r\n * v1.31: Support tooltips, by @Sly1024 and @drewnoakes\r\n * v1.32: Support frame rate limit, by @dpuyosa\r\n * v1.33: Use Date static method instead of instance, by @nnnoel\r\n *        Fix bug with tooltips when multiple charts on a page, by @jpmbiz70\r\n * v1.34: Add disabled option to TimeSeries, by @TechGuard (#91)\r\n *        Add nonRealtimeData option, by @annazhelt (#92, #93)\r\n *        Add showIntermediateLabels option, by @annazhelt (#94)\r\n *        Add displayDataFromPercentile option, by @annazhelt (#95)\r\n *        Fix bug when hiding tooltip element, by @ralphwetzel (#96)\r\n *        Support intermediate y-axis labels, by @beikeland (#99)\r\n * v1.35: Fix issue with responsive mode at high DPI, by @drewnoakes (#101)\r\n * v1.36: Add tooltipLabel to ITimeSeriesPresentationOptions.\r\n *        If tooltipLabel is present, tooltipLabel displays inside tooltip\r\n *        next to value, by @jackdesert (#102)\r\n *        Fix bug rendering issue in series fill when using scroll backwards, by @olssonfredrik\r\n *        Add title option, by @mesca\r\n *        Fix data drop stoppage by rejecting NaNs in append(), by @timdrysdale\r\n *        Allow setting interpolation per time series, by @WofWca (#123)\r\n *        Fix chart constantly jumping in 1-2 pixel steps, by @WofWca (#131)\r\n *        Fix a memory leak appearing when some `timeSeries.disabled === true`, by @WofWca (#132)\r\n *        Fix: make all lines sharp, remove the `grid.sharpLines` option by @WofWca (#134)\r\n *        Improve performance, by @WofWca (#135)\r\n *        Fix `this.delay` not being respected with `nonRealtimeData: true`, by @WofWca (#137)\r\n *        Fix series fill & stroke being inconsistent for last data time < render time, by @WofWca (#138)\r\n * v1.36.1: Fix a potential XSS when `tooltipLabel` or `strokeStyle` are controlled by users, by @WofWca\r\n */\r\n\r\n  // Date.now polyfill\r\n  Date.now = Date.now || function() { return new Date().getTime(); };\r\n\r\n  var Util = {\r\n    extend: function() {\r\n      arguments[0] = arguments[0] || {};\r\n      for (var i = 1; i < arguments.length; i++)\r\n      {\r\n        for (var key in arguments[i])\r\n        {\r\n          if (arguments[i].hasOwnProperty(key))\r\n          {\r\n            if (typeof(arguments[i][key]) === 'object') {\r\n              if (arguments[i][key] instanceof Array) {\r\n                arguments[0][key] = arguments[i][key];\r\n              } else {\r\n                arguments[0][key] = Util.extend(arguments[0][key], arguments[i][key]);\r\n              }\r\n            } else {\r\n              arguments[0][key] = arguments[i][key];\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return arguments[0];\r\n    },\r\n    binarySearch: function(data, value) {\r\n      var low = 0,\r\n          high = data.length;\r\n      while (low < high) {\r\n        var mid = (low + high) >> 1;\r\n        if (value < data[mid][0])\r\n          high = mid;\r\n        else\r\n          low = mid + 1;\r\n      }\r\n      return low;\r\n    },\r\n    // So lines (especially vertical and horizontal) look a) consistent along their length and b) sharp.\r\n    pixelSnap: function(position, lineWidth) {\r\n      if (lineWidth % 2 === 0) {\r\n        // Closest pixel edge.\r\n        return Math.round(position);\r\n      } else {\r\n        // Closest pixel center.\r\n        return Math.floor(position) + 0.5;\r\n      }\r\n    },\r\n  };\r\n\r\n  /**\r\n   * Initialises a new <code>TimeSeries</code> with optional data options.\r\n   *\r\n   * Options are of the form (defaults shown):\r\n   *\r\n   * <pre>\r\n   * {\r\n   *   resetBounds: true,        // enables/disables automatic scaling of the y-axis\r\n   *   resetBoundsInterval: 3000 // the period between scaling calculations, in millis\r\n   * }\r\n   * </pre>\r\n   *\r\n   * Presentation options for TimeSeries are specified as an argument to <code>SmoothieChart.addTimeSeries</code>.\r\n   *\r\n   * @constructor\r\n   */\r\n  function TimeSeries(options) {\r\n    this.options = Util.extend({}, TimeSeries.defaultOptions, options);\r\n    this.disabled = false;\r\n    this.clear();\r\n  }\r\n\r\n  TimeSeries.defaultOptions = {\r\n    resetBoundsInterval: 3000,\r\n    resetBounds: true\r\n  };\r\n\r\n  /**\r\n   * Clears all data and state from this TimeSeries object.\r\n   */\r\n  TimeSeries.prototype.clear = function() {\r\n    this.data = [];\r\n    this.maxValue = Number.NaN; // The maximum value ever seen in this TimeSeries.\r\n    this.minValue = Number.NaN; // The minimum value ever seen in this TimeSeries.\r\n  };\r\n\r\n  /**\r\n   * Recalculate the min/max values for this <code>TimeSeries</code> object.\r\n   *\r\n   * This causes the graph to scale itself in the y-axis.\r\n   */\r\n  TimeSeries.prototype.resetBounds = function() {\r\n    if (this.data.length) {\r\n      // Walk through all data points, finding the min/max value\r\n      this.maxValue = this.data[0][1];\r\n      this.minValue = this.data[0][1];\r\n      for (var i = 1; i < this.data.length; i++) {\r\n        var value = this.data[i][1];\r\n        if (value > this.maxValue) {\r\n          this.maxValue = value;\r\n        }\r\n        if (value < this.minValue) {\r\n          this.minValue = value;\r\n        }\r\n      }\r\n    } else {\r\n      // No data exists, so set min/max to NaN\r\n      this.maxValue = Number.NaN;\r\n      this.minValue = Number.NaN;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Adds a new data point to the <code>TimeSeries</code>, preserving chronological order.\r\n   *\r\n   * @param timestamp the position, in time, of this data point\r\n   * @param value the value of this data point\r\n   * @param sumRepeatedTimeStampValues if <code>timestamp</code> has an exact match in the series, this flag controls\r\n   * whether it is replaced, or the values summed (defaults to false.)\r\n   */\r\n  TimeSeries.prototype.append = function(timestamp, value, sumRepeatedTimeStampValues) {\r\n\t// Reject NaN\r\n\tif (isNaN(timestamp) || isNaN(value)){\r\n\t\treturn\r\n\t}  \r\n\r\n    var lastI = this.data.length - 1;\r\n    if (lastI >= 0) {\r\n      // Rewind until we find the place for the new data\r\n      var i = lastI;\r\n      while (true) {\r\n        var iThData = this.data[i];\r\n        if (timestamp >= iThData[0]) {\r\n          if (timestamp === iThData[0]) {\r\n            // Update existing values in the array\r\n            if (sumRepeatedTimeStampValues) {\r\n              // Sum this value into the existing 'bucket'\r\n              iThData[1] += value;\r\n              value = iThData[1];\r\n            } else {\r\n              // Replace the previous value\r\n              iThData[1] = value;\r\n            }\r\n          } else {\r\n            // Splice into the correct position to keep timestamps in order\r\n            this.data.splice(i + 1, 0, [timestamp, value]);\r\n          }\r\n\r\n          break;\r\n        }\r\n\r\n        i--;\r\n        if (i < 0) {\r\n          // This new item is the oldest data\r\n          this.data.splice(0, 0, [timestamp, value]);\r\n\r\n          break;\r\n        }\r\n      }\r\n    } else {\r\n      // It's the first element\r\n      this.data.push([timestamp, value]);\r\n    }\r\n\r\n    this.maxValue = isNaN(this.maxValue) ? value : Math.max(this.maxValue, value);\r\n    this.minValue = isNaN(this.minValue) ? value : Math.min(this.minValue, value);\r\n  };\r\n\r\n  TimeSeries.prototype.dropOldData = function(oldestValidTime, maxDataSetLength) {\r\n    // We must always keep one expired data point as we need this to draw the\r\n    // line that comes into the chart from the left, but any points prior to that can be removed.\r\n    var removeCount = 0;\r\n    while (this.data.length - removeCount >= maxDataSetLength && this.data[removeCount + 1][0] < oldestValidTime) {\r\n      removeCount++;\r\n    }\r\n    if (removeCount !== 0) {\r\n      this.data.splice(0, removeCount);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Initialises a new <code>SmoothieChart</code>.\r\n   *\r\n   * Options are optional, and should be of the form below. Just specify the values you\r\n   * need and the rest will be given sensible defaults as shown:\r\n   *\r\n   * <pre>\r\n   * {\r\n   *   minValue: undefined,                      // specify to clamp the lower y-axis to a given value\r\n   *   maxValue: undefined,                      // specify to clamp the upper y-axis to a given value\r\n   *   maxValueScale: 1,                         // allows proportional padding to be added above the chart. for 10% padding, specify 1.1.\r\n   *   minValueScale: 1,                         // allows proportional padding to be added below the chart. for 10% padding, specify 1.1.\r\n   *   yRangeFunction: undefined,                // function({min: , max: }) { return {min: , max: }; }\r\n   *   scaleSmoothing: 0.125,                    // controls the rate at which y-value zoom animation occurs\r\n   *   millisPerPixel: 20,                       // sets the speed at which the chart pans by\r\n   *   enableDpiScaling: true,                   // support rendering at different DPI depending on the device\r\n   *   yMinFormatter: function(min, precision) { // callback function that formats the min y value label\r\n   *     return parseFloat(min).toFixed(precision);\r\n   *   },\r\n   *   yMaxFormatter: function(max, precision) { // callback function that formats the max y value label\r\n   *     return parseFloat(max).toFixed(precision);\r\n   *   },\r\n   *   yIntermediateFormatter: function(intermediate, precision) { // callback function that formats the intermediate y value labels\r\n   *     return parseFloat(intermediate).toFixed(precision);\r\n   *   },\r\n   *   maxDataSetLength: 2,\r\n   *   interpolation: 'bezier'                   // one of 'bezier', 'linear', or 'step'\r\n   *   timestampFormatter: null,                 // optional function to format time stamps for bottom of chart\r\n   *                                             // you may use SmoothieChart.timeFormatter, or your own: function(date) { return ''; }\r\n   *   scrollBackwards: false,                   // reverse the scroll direction of the chart\r\n   *   horizontalLines: [],                      // [ { value: 0, color: '#ffffff', lineWidth: 1 } ]\r\n   *   grid:\r\n   *   {\r\n   *     fillStyle: '#000000',                   // the background colour of the chart\r\n   *     lineWidth: 1,                           // the pixel width of grid lines\r\n   *     strokeStyle: '#777777',                 // colour of grid lines\r\n   *     millisPerLine: 1000,                    // distance between vertical grid lines\r\n   *     verticalSections: 2,                    // number of vertical sections marked out by horizontal grid lines\r\n   *     borderVisible: true                     // whether the grid lines trace the border of the chart or not\r\n   *   },\r\n   *   labels\r\n   *   {\r\n   *     disabled: false,                        // enables/disables labels showing the min/max values\r\n   *     fillStyle: '#ffffff',                   // colour for text of labels,\r\n   *     fontSize: 15,\r\n   *     fontFamily: 'sans-serif',\r\n   *     precision: 2,\r\n   *     showIntermediateLabels: false,          // shows intermediate labels between min and max values along y axis\r\n   *     intermediateLabelSameAxis: true,\r\n   *   },\r\n   *   title\r\n   *   {\r\n   *     text: '',                               // the text to display on the left side of the chart\r\n   *     fillStyle: '#ffffff',                   // colour for text\r\n   *     fontSize: 15,\r\n   *     fontFamily: 'sans-serif',\r\n   *     verticalAlign: 'middle'                 // one of 'top', 'middle', or 'bottom'\r\n   *   },\r\n   *   tooltip: false                            // show tooltip when mouse is over the chart\r\n   *   tooltipLine: {                            // properties for a vertical line at the cursor position\r\n   *     lineWidth: 1,\r\n   *     strokeStyle: '#BBBBBB'\r\n   *   },\r\n   *   tooltipFormatter: SmoothieChart.tooltipFormatter, // formatter function for tooltip text\r\n   *   nonRealtimeData: false,                   // use time of latest data as current time\r\n   *   displayDataFromPercentile: 1,             // display not latest data, but data from the given percentile\r\n   *                                             // useful when trying to see old data saved by setting a high value for maxDataSetLength\r\n   *                                             // should be a value between 0 and 1\r\n   *   responsive: false,                        // whether the chart should adapt to the size of the canvas\r\n   *   limitFPS: 0                               // maximum frame rate the chart will render at, in FPS (zero means no limit)\r\n   * }\r\n   * </pre>\r\n   *\r\n   * @constructor\r\n   */\r\n  function SmoothieChart(options) {\r\n    this.options = Util.extend({}, SmoothieChart.defaultChartOptions, options);\r\n    this.seriesSet = [];\r\n    this.currentValueRange = 1;\r\n    this.currentVisMinValue = 0;\r\n    this.lastRenderTimeMillis = 0;\r\n    this.lastChartTimestamp = 0;\r\n\r\n    this.mousemove = this.mousemove.bind(this);\r\n    this.mouseout = this.mouseout.bind(this);\r\n  }\r\n\r\n  /** Formats the HTML string content of the tooltip. */\r\n  SmoothieChart.tooltipFormatter = function (timestamp, data) {\r\n      var timestampFormatter = this.options.timestampFormatter || SmoothieChart.timeFormatter,\r\n          // A dummy element to hold children. Maybe there's a better way.\r\n          elements = document.createElement('div'),\r\n          label;\r\n      elements.appendChild(document.createTextNode(\r\n        timestampFormatter(new Date(timestamp))\r\n      ));\r\n\r\n      for (var i = 0; i < data.length; ++i) {\r\n        label = data[i].series.options.tooltipLabel || ''\r\n        if (label !== ''){\r\n            label = label + ' ';\r\n        }\r\n        var dataEl = document.createElement('span');\r\n        dataEl.style.color = data[i].series.options.strokeStyle;\r\n        dataEl.appendChild(document.createTextNode(\r\n          label + this.options.yMaxFormatter(data[i].value, this.options.labels.precision)\r\n        ));\r\n        elements.appendChild(document.createElement('br'));\r\n        elements.appendChild(dataEl);\r\n      }\r\n\r\n      return elements.innerHTML;\r\n  };\r\n\r\n  SmoothieChart.defaultChartOptions = {\r\n    millisPerPixel: 20,\r\n    enableDpiScaling: true,\r\n    yMinFormatter: function(min, precision) {\r\n      return parseFloat(min).toFixed(precision);\r\n    },\r\n    yMaxFormatter: function(max, precision) {\r\n      return parseFloat(max).toFixed(precision);\r\n    },\r\n    yIntermediateFormatter: function(intermediate, precision) {\r\n      return parseFloat(intermediate).toFixed(precision);\r\n    },\r\n    maxValueScale: 1,\r\n    minValueScale: 1,\r\n    interpolation: 'bezier',\r\n    scaleSmoothing: 0.125,\r\n    maxDataSetLength: 2,\r\n    scrollBackwards: false,\r\n    displayDataFromPercentile: 1,\r\n    grid: {\r\n      fillStyle: '#000000',\r\n      strokeStyle: '#777777',\r\n      lineWidth: 2,\r\n      millisPerLine: 1000,\r\n      verticalSections: 2,\r\n      borderVisible: true\r\n    },\r\n    labels: {\r\n      fillStyle: '#ffffff',\r\n      disabled: false,\r\n      fontSize: 10,\r\n      fontFamily: 'monospace',\r\n      precision: 2,\r\n      showIntermediateLabels: false,\r\n      intermediateLabelSameAxis: true,\r\n    },\r\n    title: {\r\n      text: '',\r\n      fillStyle: '#ffffff',\r\n      fontSize: 15,\r\n      fontFamily: 'monospace',\r\n      verticalAlign: 'middle'\r\n    },\r\n    horizontalLines: [],\r\n    tooltip: false,\r\n    tooltipLine: {\r\n      lineWidth: 1,\r\n      strokeStyle: '#BBBBBB'\r\n    },\r\n    tooltipFormatter: SmoothieChart.tooltipFormatter,\r\n    nonRealtimeData: false,\r\n    responsive: false,\r\n    limitFPS: 0\r\n  };\r\n\r\n  // Based on http://inspirit.github.com/jsfeat/js/compatibility.js\r\n  SmoothieChart.AnimateCompatibility = (function() {\r\n    var requestAnimationFrame = function(callback, element) {\r\n          var requestAnimationFrame =\r\n            window.requestAnimationFrame        ||\r\n            window.webkitRequestAnimationFrame  ||\r\n            window.mozRequestAnimationFrame     ||\r\n            window.oRequestAnimationFrame       ||\r\n            window.msRequestAnimationFrame      ||\r\n            function(callback) {\r\n              return window.setTimeout(function() {\r\n                callback(Date.now());\r\n              }, 16);\r\n            };\r\n          return requestAnimationFrame.call(window, callback, element);\r\n        },\r\n        cancelAnimationFrame = function(id) {\r\n          var cancelAnimationFrame =\r\n            window.cancelAnimationFrame ||\r\n            function(id) {\r\n              clearTimeout(id);\r\n            };\r\n          return cancelAnimationFrame.call(window, id);\r\n        };\r\n\r\n    return {\r\n      requestAnimationFrame: requestAnimationFrame,\r\n      cancelAnimationFrame: cancelAnimationFrame\r\n    };\r\n  })();\r\n\r\n  SmoothieChart.defaultSeriesPresentationOptions = {\r\n    lineWidth: 1,\r\n    strokeStyle: '#ffffff'\r\n  };\r\n\r\n  /**\r\n   * Adds a <code>TimeSeries</code> to this chart, with optional presentation options.\r\n   *\r\n   * Presentation options should be of the form (defaults shown):\r\n   *\r\n   * <pre>\r\n   * {\r\n   *   lineWidth: 1,\r\n   *   strokeStyle: '#ffffff',\r\n   *   fillStyle: undefined,\r\n   *   interpolation: undefined;\r\n   *   tooltipLabel: undefined\r\n   * }\r\n   * </pre>\r\n   */\r\n  SmoothieChart.prototype.addTimeSeries = function(timeSeries, options) {\r\n    this.seriesSet.push({timeSeries: timeSeries, options: Util.extend({}, SmoothieChart.defaultSeriesPresentationOptions, options)});\r\n    if (timeSeries.options.resetBounds && timeSeries.options.resetBoundsInterval > 0) {\r\n      timeSeries.resetBoundsTimerId = setInterval(\r\n        function() {\r\n          timeSeries.resetBounds();\r\n        },\r\n        timeSeries.options.resetBoundsInterval\r\n      );\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Removes the specified <code>TimeSeries</code> from the chart.\r\n   */\r\n  SmoothieChart.prototype.removeTimeSeries = function(timeSeries) {\r\n    // Find the correct timeseries to remove, and remove it\r\n    var numSeries = this.seriesSet.length;\r\n    for (var i = 0; i < numSeries; i++) {\r\n      if (this.seriesSet[i].timeSeries === timeSeries) {\r\n        this.seriesSet.splice(i, 1);\r\n        break;\r\n      }\r\n    }\r\n    // If a timer was operating for that timeseries, remove it\r\n    if (timeSeries.resetBoundsTimerId) {\r\n      // Stop resetting the bounds, if we were\r\n      clearInterval(timeSeries.resetBoundsTimerId);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Gets render options for the specified <code>TimeSeries</code>.\r\n   *\r\n   * As you may use a single <code>TimeSeries</code> in multiple charts with different formatting in each usage,\r\n   * these settings are stored in the chart.\r\n   */\r\n  SmoothieChart.prototype.getTimeSeriesOptions = function(timeSeries) {\r\n    // Find the correct timeseries to remove, and remove it\r\n    var numSeries = this.seriesSet.length;\r\n    for (var i = 0; i < numSeries; i++) {\r\n      if (this.seriesSet[i].timeSeries === timeSeries) {\r\n        return this.seriesSet[i].options;\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Brings the specified <code>TimeSeries</code> to the top of the chart. It will be rendered last.\r\n   */\r\n  SmoothieChart.prototype.bringToFront = function(timeSeries) {\r\n    // Find the correct timeseries to remove, and remove it\r\n    var numSeries = this.seriesSet.length;\r\n    for (var i = 0; i < numSeries; i++) {\r\n      if (this.seriesSet[i].timeSeries === timeSeries) {\r\n        var set = this.seriesSet.splice(i, 1);\r\n        this.seriesSet.push(set[0]);\r\n        break;\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Instructs the <code>SmoothieChart</code> to start rendering to the provided canvas, with specified delay.\r\n   *\r\n   * @param canvas the target canvas element\r\n   * @param delayMillis an amount of time to wait before a data point is shown. This can prevent the end of the series\r\n   * from appearing on screen, with new values flashing into view, at the expense of some latency.\r\n   */\r\n  SmoothieChart.prototype.streamTo = function(canvas, delayMillis) {\r\n    this.canvas = canvas;\r\n\r\n    this.clientWidth = parseInt(this.canvas.getAttribute('width'));\r\n    this.clientHeight = parseInt(this.canvas.getAttribute('height'));\r\n\r\n    this.delay = delayMillis;\r\n    this.start();\r\n  };\r\n\r\n  SmoothieChart.prototype.getTooltipEl = function () {\r\n    // Create the tool tip element lazily\r\n    if (!this.tooltipEl) {\r\n      this.tooltipEl = document.createElement('div');\r\n      this.tooltipEl.className = 'smoothie-chart-tooltip';\r\n      this.tooltipEl.style.pointerEvents = 'none';\r\n      this.tooltipEl.style.position = 'absolute';\r\n      this.tooltipEl.style.display = 'none';\r\n      document.body.appendChild(this.tooltipEl);\r\n    }\r\n    return this.tooltipEl;\r\n  };\r\n\r\n  SmoothieChart.prototype.updateTooltip = function () {\r\n    if(!this.options.tooltip){\r\n     return; \r\n    }\r\n    var el = this.getTooltipEl();\r\n\r\n    if (!this.mouseover || !this.options.tooltip) {\r\n      el.style.display = 'none';\r\n      return;\r\n    }\r\n\r\n    var time = this.lastChartTimestamp;\r\n\r\n    // x pixel to time\r\n    var t = this.options.scrollBackwards\r\n      ? time - this.mouseX * this.options.millisPerPixel\r\n      : time - (this.clientWidth - this.mouseX) * this.options.millisPerPixel;\r\n\r\n    var data = [];\r\n\r\n     // For each data set...\r\n    for (var d = 0; d < this.seriesSet.length; d++) {\r\n      var timeSeries = this.seriesSet[d].timeSeries;\r\n      if (timeSeries.disabled) {\r\n          continue;\r\n      }\r\n\r\n      // find datapoint closest to time 't'\r\n      var closeIdx = Util.binarySearch(timeSeries.data, t);\r\n      if (closeIdx > 0 && closeIdx < timeSeries.data.length) {\r\n        data.push({ series: this.seriesSet[d], index: closeIdx, value: timeSeries.data[closeIdx][1] });\r\n      }\r\n    }\r\n\r\n    if (data.length) {\r\n      // TODO make `tooltipFormatter` return element(s) instead of an HTML string so it's harder for users\r\n      // to introduce an XSS. This would be a breaking change.\r\n      el.innerHTML = this.options.tooltipFormatter.call(this, t, data);\r\n      el.style.display = 'block';\r\n    } else {\r\n      el.style.display = 'none';\r\n    }\r\n  };\r\n\r\n  SmoothieChart.prototype.mousemove = function (evt) {\r\n    this.mouseover = true;\r\n    this.mouseX = evt.offsetX;\r\n    this.mouseY = evt.offsetY;\r\n    this.mousePageX = evt.pageX;\r\n    this.mousePageY = evt.pageY;\r\n    if(!this.options.tooltip){\r\n     return; \r\n    }\r\n    var el = this.getTooltipEl();\r\n    el.style.top = Math.round(this.mousePageY) + 'px';\r\n    el.style.left = Math.round(this.mousePageX) + 'px';\r\n    this.updateTooltip();\r\n  };\r\n\r\n  SmoothieChart.prototype.mouseout = function () {\r\n    this.mouseover = false;\r\n    this.mouseX = this.mouseY = -1;\r\n    if (this.tooltipEl)\r\n      this.tooltipEl.style.display = 'none';\r\n  };\r\n\r\n  /**\r\n   * Make sure the canvas has the optimal resolution for the device's pixel ratio.\r\n   */\r\n  SmoothieChart.prototype.resize = function () {\r\n    var dpr = !this.options.enableDpiScaling || !window ? 1 : window.devicePixelRatio,\r\n        width, height;\r\n    if (this.options.responsive) {\r\n      // Newer behaviour: Use the canvas's size in the layout, and set the internal\r\n      // resolution according to that size and the device pixel ratio (eg: high DPI)\r\n      width = this.canvas.offsetWidth;\r\n      height = this.canvas.offsetHeight;\r\n\r\n      if (width !== this.lastWidth) {\r\n        this.lastWidth = width;\r\n        this.canvas.setAttribute('width', (Math.floor(width * dpr)).toString());\r\n        this.canvas.getContext('2d').scale(dpr, dpr);\r\n      }\r\n      if (height !== this.lastHeight) {\r\n        this.lastHeight = height;\r\n        this.canvas.setAttribute('height', (Math.floor(height * dpr)).toString());\r\n        this.canvas.getContext('2d').scale(dpr, dpr);\r\n      }\r\n\r\n      this.clientWidth = width;\r\n      this.clientHeight = height;\r\n    } else {\r\n      width = parseInt(this.canvas.getAttribute('width'));\r\n      height = parseInt(this.canvas.getAttribute('height'));\r\n\r\n      if (dpr !== 1) {\r\n        // Older behaviour: use the canvas's inner dimensions and scale the element's size\r\n        // according to that size and the device pixel ratio (eg: high DPI)\r\n\r\n        if (Math.floor(this.clientWidth * dpr) !== width) {\r\n          this.canvas.setAttribute('width', (Math.floor(width * dpr)).toString());\r\n          this.canvas.style.width = width + 'px';\r\n          this.clientWidth = width;\r\n          this.canvas.getContext('2d').scale(dpr, dpr);\r\n        }\r\n\r\n        if (Math.floor(this.clientHeight * dpr) !== height) {\r\n          this.canvas.setAttribute('height', (Math.floor(height * dpr)).toString());\r\n          this.canvas.style.height = height + 'px';\r\n          this.clientHeight = height;\r\n          this.canvas.getContext('2d').scale(dpr, dpr);\r\n        }\r\n      } else {\r\n        this.clientWidth = width;\r\n        this.clientHeight = height;\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Starts the animation of this chart.\r\n   */\r\n  SmoothieChart.prototype.start = function() {\r\n    if (this.frame) {\r\n      // We're already running, so just return\r\n      return;\r\n    }\r\n\r\n    this.canvas.addEventListener('mousemove', this.mousemove);\r\n    this.canvas.addEventListener('mouseout', this.mouseout);\r\n\r\n    // Renders a frame, and queues the next frame for later rendering\r\n    var animate = function() {\r\n      this.frame = SmoothieChart.AnimateCompatibility.requestAnimationFrame(function() {\r\n        if(this.options.nonRealtimeData){\r\n           var dateZero = new Date(0);\r\n           // find the data point with the latest timestamp\r\n           var maxTimeStamp = this.seriesSet.reduce(function(max, series){\r\n             var dataSet = series.timeSeries.data;\r\n             var indexToCheck = Math.round(this.options.displayDataFromPercentile * dataSet.length) - 1;\r\n             indexToCheck = indexToCheck >= 0 ? indexToCheck : 0;\r\n             indexToCheck = indexToCheck <= dataSet.length -1 ? indexToCheck : dataSet.length -1;\r\n             if(dataSet && dataSet.length > 0)\r\n             {\r\n              // timestamp corresponds to element 0 of the data point\r\n              var lastDataTimeStamp = dataSet[indexToCheck][0];\r\n              max = max > lastDataTimeStamp ? max : lastDataTimeStamp;\r\n             }\r\n             return max;\r\n          }.bind(this), dateZero);\r\n          // use the max timestamp as current time\r\n          this.render(this.canvas, maxTimeStamp > dateZero ? maxTimeStamp : null);\r\n        } else {\r\n          this.render();\r\n        }\r\n        animate();\r\n      }.bind(this));\r\n    }.bind(this);\r\n\r\n    animate();\r\n  };\r\n\r\n  /**\r\n   * Stops the animation of this chart.\r\n   */\r\n  SmoothieChart.prototype.stop = function() {\r\n    if (this.frame) {\r\n      SmoothieChart.AnimateCompatibility.cancelAnimationFrame(this.frame);\r\n      delete this.frame;\r\n      this.canvas.removeEventListener('mousemove', this.mousemove);\r\n      this.canvas.removeEventListener('mouseout', this.mouseout);\r\n    }\r\n  };\r\n\r\n  SmoothieChart.prototype.updateValueRange = function() {\r\n    // Calculate the current scale of the chart, from all time series.\r\n    var chartOptions = this.options,\r\n        chartMaxValue = Number.NaN,\r\n        chartMinValue = Number.NaN;\r\n\r\n    for (var d = 0; d < this.seriesSet.length; d++) {\r\n      // TODO(ndunn): We could calculate / track these values as they stream in.\r\n      var timeSeries = this.seriesSet[d].timeSeries;\r\n      if (timeSeries.disabled) {\r\n          continue;\r\n      }\r\n\r\n      if (!isNaN(timeSeries.maxValue)) {\r\n        chartMaxValue = !isNaN(chartMaxValue) ? Math.max(chartMaxValue, timeSeries.maxValue) : timeSeries.maxValue;\r\n      }\r\n\r\n      if (!isNaN(timeSeries.minValue)) {\r\n        chartMinValue = !isNaN(chartMinValue) ? Math.min(chartMinValue, timeSeries.minValue) : timeSeries.minValue;\r\n      }\r\n    }\r\n\r\n    // Scale the chartMaxValue to add padding at the top if required\r\n    if (chartOptions.maxValue != null) {\r\n      chartMaxValue = chartOptions.maxValue;\r\n    } else {\r\n      chartMaxValue *= chartOptions.maxValueScale;\r\n    }\r\n\r\n    // Set the minimum if we've specified one\r\n    if (chartOptions.minValue != null) {\r\n      chartMinValue = chartOptions.minValue;\r\n    } else {\r\n      chartMinValue -= Math.abs(chartMinValue * chartOptions.minValueScale - chartMinValue);\r\n    }\r\n\r\n    // If a custom range function is set, call it\r\n    if (this.options.yRangeFunction) {\r\n      var range = this.options.yRangeFunction({min: chartMinValue, max: chartMaxValue});\r\n      chartMinValue = range.min;\r\n      chartMaxValue = range.max;\r\n    }\r\n\r\n    if (!isNaN(chartMaxValue) && !isNaN(chartMinValue)) {\r\n      var targetValueRange = chartMaxValue - chartMinValue;\r\n      var valueRangeDiff = (targetValueRange - this.currentValueRange);\r\n      var minValueDiff = (chartMinValue - this.currentVisMinValue);\r\n      this.isAnimatingScale = Math.abs(valueRangeDiff) > 0.1 || Math.abs(minValueDiff) > 0.1;\r\n      this.currentValueRange += chartOptions.scaleSmoothing * valueRangeDiff;\r\n      this.currentVisMinValue += chartOptions.scaleSmoothing * minValueDiff;\r\n    }\r\n\r\n    this.valueRange = { min: chartMinValue, max: chartMaxValue };\r\n  };\r\n\r\n  SmoothieChart.prototype.render = function(canvas, time) {\r\n    var nowMillis = Date.now();\r\n\r\n    // Respect any frame rate limit.\r\n    if (this.options.limitFPS > 0 && nowMillis - this.lastRenderTimeMillis < (1000/this.options.limitFPS))\r\n      return;\r\n\r\n    time = (time || nowMillis) - (this.delay || 0);\r\n\r\n    // Round time down to pixel granularity, so motion appears smoother.\r\n    time -= time % this.options.millisPerPixel;\r\n\r\n    if (!this.isAnimatingScale) {\r\n      // We're not animating. We can use the last render time and the scroll speed to work out whether\r\n      // we actually need to paint anything yet. If not, we can return immediately.\r\n      var sameTime = this.lastChartTimestamp === time;\r\n      if (sameTime) {\r\n        // Render at least every 1/6th of a second. The canvas may be resized, which there is\r\n        // no reliable way to detect.\r\n        var needToRenderInCaseCanvasResized = nowMillis - this.lastRenderTimeMillis > 1000/6;\r\n        if (!needToRenderInCaseCanvasResized) {\r\n          return;\r\n        }\r\n      }\r\n    }\r\n\r\n    this.lastRenderTimeMillis = nowMillis;\r\n    this.lastChartTimestamp = time;\r\n\r\n    this.resize();\r\n\r\n    canvas = canvas || this.canvas;\r\n    var context = canvas.getContext('2d'),\r\n        chartOptions = this.options,\r\n        // Using `this.clientWidth` instead of `canvas.clientWidth` because the latter is slow.\r\n        dimensions = { top: 0, left: 0, width: this.clientWidth, height: this.clientHeight },\r\n        // Calculate the threshold time for the oldest data points.\r\n        oldestValidTime = time - (dimensions.width * chartOptions.millisPerPixel),\r\n        valueToYPosition = function(value, lineWidth) {\r\n          var offset = value - this.currentVisMinValue,\r\n              unsnapped = this.currentValueRange === 0\r\n                ? dimensions.height\r\n                : dimensions.height * (1 - offset / this.currentValueRange);\r\n          return Util.pixelSnap(unsnapped, lineWidth);\r\n        }.bind(this),\r\n        timeToXPosition = function(t, lineWidth) {\r\n          var unsnapped = chartOptions.scrollBackwards\r\n            ? (time - t) / chartOptions.millisPerPixel\r\n            : dimensions.width - ((time - t) / chartOptions.millisPerPixel);\r\n          return Util.pixelSnap(unsnapped, lineWidth);\r\n        };\r\n\r\n    this.updateValueRange();\r\n\r\n    context.font = chartOptions.labels.fontSize + 'px ' + chartOptions.labels.fontFamily;\r\n\r\n    // Save the state of the canvas context, any transformations applied in this method\r\n    // will get removed from the stack at the end of this method when .restore() is called.\r\n    context.save();\r\n\r\n    // Move the origin.\r\n    context.translate(dimensions.left, dimensions.top);\r\n\r\n    // Create a clipped rectangle - anything we draw will be constrained to this rectangle.\r\n    // This prevents the occasional pixels from curves near the edges overrunning and creating\r\n    // screen cheese (that phrase should need no explanation).\r\n    context.beginPath();\r\n    context.rect(0, 0, dimensions.width, dimensions.height);\r\n    context.clip();\r\n\r\n    // Clear the working area.\r\n    context.save();\r\n    context.fillStyle = chartOptions.grid.fillStyle;\r\n    context.clearRect(0, 0, dimensions.width, dimensions.height);\r\n    context.fillRect(0, 0, dimensions.width, dimensions.height);\r\n    context.restore();\r\n\r\n    // Grid lines...\r\n    context.save();\r\n    context.lineWidth = chartOptions.grid.lineWidth;\r\n    context.strokeStyle = chartOptions.grid.strokeStyle;\r\n    // Vertical (time) dividers.\r\n    if (chartOptions.grid.millisPerLine > 0) {\r\n      context.beginPath();\r\n      for (var t = time - (time % chartOptions.grid.millisPerLine);\r\n           t >= oldestValidTime;\r\n           t -= chartOptions.grid.millisPerLine) {\r\n        var gx = timeToXPosition(t, chartOptions.grid.lineWidth);\r\n        context.moveTo(gx, 0);\r\n        context.lineTo(gx, dimensions.height);\r\n      }\r\n      context.stroke();\r\n      context.closePath();\r\n    }\r\n\r\n    // Horizontal (value) dividers.\r\n    for (var v = 1; v < chartOptions.grid.verticalSections; v++) {\r\n      var gy = Util.pixelSnap(v * dimensions.height / chartOptions.grid.verticalSections, chartOptions.grid.lineWidth);\r\n      context.beginPath();\r\n      context.moveTo(0, gy);\r\n      context.lineTo(dimensions.width, gy);\r\n      context.stroke();\r\n      context.closePath();\r\n    }\r\n    // Bounding rectangle.\r\n    if (chartOptions.grid.borderVisible) {\r\n      context.beginPath();\r\n      context.strokeRect(0, 0, dimensions.width, dimensions.height);\r\n      context.closePath();\r\n    }\r\n    context.restore();\r\n\r\n    // Draw any horizontal lines...\r\n    if (chartOptions.horizontalLines && chartOptions.horizontalLines.length) {\r\n      for (var hl = 0; hl < chartOptions.horizontalLines.length; hl++) {\r\n        var line = chartOptions.horizontalLines[hl],\r\n            lineWidth = line.lineWidth || 1,\r\n            hly = valueToYPosition(line.value, lineWidth);\r\n        context.strokeStyle = line.color || '#ffffff';\r\n        context.lineWidth = lineWidth;\r\n        context.beginPath();\r\n        context.moveTo(0, hly);\r\n        context.lineTo(dimensions.width, hly);\r\n        context.stroke();\r\n        context.closePath();\r\n      }\r\n    }\r\n\r\n    // For each data set...\r\n    for (var d = 0; d < this.seriesSet.length; d++) {\r\n      var timeSeries = this.seriesSet[d].timeSeries,\r\n          dataSet = timeSeries.data;\r\n\r\n      // Delete old data that's moved off the left of the chart.\r\n      timeSeries.dropOldData(oldestValidTime, chartOptions.maxDataSetLength);\r\n      if (dataSet.length <= 1 || timeSeries.disabled) {\r\n          continue;\r\n      }\r\n      context.save();\r\n\r\n      var seriesOptions = this.seriesSet[d].options,\r\n          // Keep in mind that `context.lineWidth = 0` doesn't actually set it to `0`.\r\n          drawStroke = seriesOptions.strokeStyle && seriesOptions.strokeStyle !== 'none',\r\n          lineWidthMaybeZero = drawStroke ? seriesOptions.lineWidth : 0;\r\n\r\n      // Draw the line...\r\n      context.beginPath();\r\n      // Retain lastX, lastY for calculating the control points of bezier curves.\r\n      var firstX = timeToXPosition(dataSet[0][0], lineWidthMaybeZero),\r\n        firstY = valueToYPosition(dataSet[0][1], lineWidthMaybeZero),\r\n        lastX = firstX,\r\n        lastY = firstY,\r\n        draw;\r\n      context.moveTo(firstX, firstY);\r\n      switch (seriesOptions.interpolation || chartOptions.interpolation) {\r\n        case \"linear\":\r\n        case \"line\": {\r\n          draw = function(x, y, lastX, lastY) {\r\n            context.lineTo(x,y);\r\n          }\r\n          break;\r\n        }\r\n        case \"bezier\":\r\n        default: {\r\n          // Great explanation of Bezier curves: http://en.wikipedia.org/wiki/Bezier_curve#Quadratic_curves\r\n          //\r\n          // Assuming A was the last point in the line plotted and B is the new point,\r\n          // we draw a curve with control points P and Q as below.\r\n          //\r\n          // A---P\r\n          //     |\r\n          //     |\r\n          //     |\r\n          //     Q---B\r\n          //\r\n          // Importantly, A and P are at the same y coordinate, as are B and Q. This is\r\n          // so adjacent curves appear to flow as one.\r\n          //\r\n          draw = function(x, y, lastX, lastY) {\r\n            context.bezierCurveTo( // startPoint (A) is implicit from last iteration of loop\r\n              Math.round((lastX + x) / 2), lastY, // controlPoint1 (P)\r\n              Math.round((lastX + x)) / 2, y, // controlPoint2 (Q)\r\n              x, y); // endPoint (B)\r\n          }\r\n          break;\r\n        }\r\n        case \"step\": {\r\n          draw = function(x, y, lastX, lastY) {\r\n            context.lineTo(x,lastY);\r\n            context.lineTo(x,y);\r\n          }\r\n          break;\r\n        }\r\n      }\r\n\r\n      for (var i = 1; i < dataSet.length; i++) {\r\n        var iThData = dataSet[i],\r\n            x = timeToXPosition(iThData[0], lineWidthMaybeZero),\r\n            y = valueToYPosition(iThData[1], lineWidthMaybeZero);\r\n        draw(x, y, lastX, lastY);\r\n        lastX = x; lastY = y;\r\n      }\r\n\r\n      if (drawStroke) {\r\n        context.lineWidth = seriesOptions.lineWidth;\r\n        context.strokeStyle = seriesOptions.strokeStyle;\r\n        context.stroke();\r\n      }\r\n\r\n      if (seriesOptions.fillStyle) {\r\n        // Close up the fill region.\r\n        context.lineTo(lastX, dimensions.height + lineWidthMaybeZero + 1);\r\n        context.lineTo(firstX, dimensions.height + lineWidthMaybeZero + 1);\r\n\r\n        context.fillStyle = seriesOptions.fillStyle;\r\n        context.fill();\r\n      }\r\n\r\n      context.restore();\r\n    }\r\n\r\n    if (chartOptions.tooltip && this.mouseX >= 0) {\r\n      // Draw vertical bar to show tooltip position\r\n      context.lineWidth = chartOptions.tooltipLine.lineWidth;\r\n      context.strokeStyle = chartOptions.tooltipLine.strokeStyle;\r\n      context.beginPath();\r\n      context.moveTo(this.mouseX, 0);\r\n      context.lineTo(this.mouseX, dimensions.height);\r\n      context.closePath();\r\n      context.stroke();\r\n    }\r\n    this.updateTooltip();\r\n\r\n    var labelsOptions = chartOptions.labels;\r\n    // Draw the axis values on the chart.\r\n    if (!labelsOptions.disabled && !isNaN(this.valueRange.min) && !isNaN(this.valueRange.max)) {\r\n      var maxValueString = chartOptions.yMaxFormatter(this.valueRange.max, labelsOptions.precision),\r\n          minValueString = chartOptions.yMinFormatter(this.valueRange.min, labelsOptions.precision),\r\n          maxLabelPos = chartOptions.scrollBackwards ? 0 : dimensions.width - context.measureText(maxValueString).width - 2,\r\n          minLabelPos = chartOptions.scrollBackwards ? 0 : dimensions.width - context.measureText(minValueString).width - 2;\r\n      context.fillStyle = labelsOptions.fillStyle;\r\n      context.fillText(maxValueString, maxLabelPos, labelsOptions.fontSize);\r\n      context.fillText(minValueString, minLabelPos, dimensions.height - 2);\r\n    }\r\n\r\n    // Display intermediate y axis labels along y-axis to the left of the chart\r\n    if ( labelsOptions.showIntermediateLabels\r\n          && !isNaN(this.valueRange.min) && !isNaN(this.valueRange.max)\r\n          && chartOptions.grid.verticalSections > 0) {\r\n      // show a label above every vertical section divider\r\n      var step = (this.valueRange.max - this.valueRange.min) / chartOptions.grid.verticalSections;\r\n      var stepPixels = dimensions.height / chartOptions.grid.verticalSections;\r\n      for (var v = 1; v < chartOptions.grid.verticalSections; v++) {\r\n        var gy = dimensions.height - Math.round(v * stepPixels),\r\n            yValue = chartOptions.yIntermediateFormatter(this.valueRange.min + (v * step), labelsOptions.precision),\r\n            //left of right axis?\r\n            intermediateLabelPos =\r\n              labelsOptions.intermediateLabelSameAxis\r\n              ? (chartOptions.scrollBackwards ? 0 : dimensions.width - context.measureText(yValue).width - 2)\r\n              : (chartOptions.scrollBackwards ? dimensions.width - context.measureText(yValue).width - 2 : 0);\r\n\r\n        context.fillText(yValue, intermediateLabelPos, gy - chartOptions.grid.lineWidth);\r\n      }\r\n    }\r\n\r\n    // Display timestamps along x-axis at the bottom of the chart.\r\n    if (chartOptions.timestampFormatter && chartOptions.grid.millisPerLine > 0) {\r\n      var textUntilX = chartOptions.scrollBackwards\r\n        ? context.measureText(minValueString).width\r\n        : dimensions.width - context.measureText(minValueString).width + 4;\r\n      for (var t = time - (time % chartOptions.grid.millisPerLine);\r\n           t >= oldestValidTime;\r\n           t -= chartOptions.grid.millisPerLine) {\r\n        var gx = timeToXPosition(t, 0);\r\n        // Only draw the timestamp if it won't overlap with the previously drawn one.\r\n        if ((!chartOptions.scrollBackwards && gx < textUntilX) || (chartOptions.scrollBackwards && gx > textUntilX))  {\r\n          // Formats the timestamp based on user specified formatting function\r\n          // SmoothieChart.timeFormatter function above is one such formatting option\r\n          var tx = new Date(t),\r\n            ts = chartOptions.timestampFormatter(tx),\r\n            tsWidth = context.measureText(ts).width;\r\n\r\n          textUntilX = chartOptions.scrollBackwards\r\n            ? gx + tsWidth + 2\r\n            : gx - tsWidth - 2;\r\n\r\n          context.fillStyle = chartOptions.labels.fillStyle;\r\n          if(chartOptions.scrollBackwards) {\r\n            context.fillText(ts, gx, dimensions.height - 2);\r\n          } else {\r\n            context.fillText(ts, gx - tsWidth, dimensions.height - 2);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Display title.\r\n    if (chartOptions.title.text !== '') {\r\n      context.font = chartOptions.title.fontSize + 'px ' + chartOptions.title.fontFamily;\r\n      var titleXPos = chartOptions.scrollBackwards ? dimensions.width - context.measureText(chartOptions.title.text).width - 2 : 2;\r\n      if (chartOptions.title.verticalAlign == 'bottom') {\r\n        context.textBaseline = 'bottom';\r\n        var titleYPos = dimensions.height;\r\n      } else if (chartOptions.title.verticalAlign == 'middle') {\r\n        context.textBaseline = 'middle';\r\n        var titleYPos = dimensions.height / 2;\r\n      } else {\r\n        context.textBaseline = 'top';\r\n        var titleYPos = 0;\r\n      }\r\n      context.fillStyle = chartOptions.title.fillStyle;\r\n      context.fillText(chartOptions.title.text, titleXPos, titleYPos);\r\n    }\r\n\r\n    context.restore(); // See .save() above.\r\n  };\r\n\r\n  // Sample timestamp formatting function\r\n  SmoothieChart.timeFormatter = function(date) {\r\n    function pad2(number) { return (number < 10 ? '0' : '') + number }\r\n    return pad2(date.getHours()) + ':' + pad2(date.getMinutes()) + ':' + pad2(date.getSeconds());\r\n  };\r\n\r\n  exports.TimeSeries = TimeSeries;\r\n  exports.SmoothieChart = SmoothieChart;\r\n\r\n})( false ? 0 : exports);\r\n\r\n\n\n//# sourceURL=webpack://piscope/./node_modules/smoothie/smoothie.js?");

/***/ }),

/***/ "./src/drawer.js":
/*!***********************!*\
  !*** ./src/drawer.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var smoothie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! smoothie */ \"./node_modules/smoothie/smoothie.js\");\n/* harmony import */ var smoothie__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(smoothie__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _fitter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fitter.js */ \"./src/fitter.js\");\n// Purpose: This file contains the code for the drawer.\n// Separated out to a js file so eslint checks it.\n\n\n\nconst canvas = document.getElementById('myChart');\nconst smoothie = new smoothie__WEBPACK_IMPORTED_MODULE_0__.SmoothieChart({\n  millisPerPixel: 400,\n  minValue: -2000, // to allow for error channels, where an error of 0 displays as -1000\n  maxValue: 3500,\n  grid: {fillStyle: '#f5f7e9', strokeStyle: 'rgba(150,150,150,0.3)', millisPerLine: 60000, verticalSections: 6, lineWidth: 1},\n  tooltipLine: {strokeStyle: '#bbbbbb'},\n  labels: {fillStyle: '#000000'},\n});\nlet loadBundle = true; // When we first start we want to load all the\n// data from the server to get the chart up to date.\nconst errorOffset = -1000;\nconst errorScale = 100;\n\nconst addError = ({channel, time, error}) => {\n  errorLines[channel].append(time, error * errorScale + errorOffset);\n};\n\nconst fitters = []; // the straigth line fitters for each channel.\nconst lines = [];\nconst errorLines = [];\nconst numberOfLines = 2;\nconst colors = ['rgba(0, 0, 255, 1)', 'rgba(255, 0, 0, 1)'];\nfor (let i = 0; i < numberOfLines; i++) {\n  lines[i] = new smoothie__WEBPACK_IMPORTED_MODULE_0__.TimeSeries();\n  errorLines[i] = new smoothie__WEBPACK_IMPORTED_MODULE_0__.TimeSeries();\n  fitters[i] = new _fitter_js__WEBPACK_IMPORTED_MODULE_1__.Fitter({channel: i, addError});\n  smoothie.addTimeSeries(lines[i], {strokeStyle: colors[i], /*fillStyle: 'rgba(0, 255, 0, 0.6)',*/ lineWidth: 1});\n  smoothie.addTimeSeries(errorLines[i], {strokeStyle: colors[i], /*fillStyle: 'rgba(0, 255, 0, 0.6)',*/ lineWidth: 1});\n}\nsmoothie.streamTo(canvas, 1000);\n\nconst connectWebSocket = () => {\n  const ws = new WebSocket('ws://localhost:8080');\n\n  ws.onopen = (event) => {\n    console.log(`Connected to WebSocket. event:${JSON.stringify(event)}`);\n  };\n\n  ws.onmessage = function (event) {\n    const data = JSON.parse(event.data);\n    if (Array.isArray(data) && loadBundle) {\n      // This is a bundle of data to get the chart up to date.\n      // We haven't plotted data yet, so we use this bundle to get the chart up to date.\n      data.forEach((d) => {\n        addReading(d);\n      });\n      return;\n    }\n    // Once we start receiving individual data, we don't want to load the bundle again.\n    // The bundle will be resent by the server if the connection drops.\n    loadBundle = false;\n    // It is not an array, so it is a single reading. Print the reading too.\n    addReading(data, true);\n  };\n\n  ws.onclose = (event) => {\n    // If the socket drops - it happens - we just reopen it.\n    if (event.wasClean) {\n      console.log(`Closed cleanly, code=${event.code}, reason=${event.reason}`);\n    } else {\n      // Connection was not closed cleanly, maybe server process crashed or network issues.\n      // We can try to reconnect here.\n      console.log('WebSocket connection closed unexpectedly. Attempting to reconnect...');\n    }\n    setTimeout(connectWebSocket, 5000); // Try to reconnect after 5 seconds.\n  };\n\n  const addReading = (data, print = false) => {\n    if (!data?.time) {\n      console.log('no time in data', data);\n      return;\n    }\n    const {channel = 0, time, reading} = data;\n    if (channel >= numberOfLines) {\n      console.log(`channel ${channel} is out of range`);\n      return;\n    }\n    lines[channel].append(time, Number(reading));\n    fitters[channel].fitLineIfTrigger(data);\n    if (print) {\n      console.log(`channel:${channel} time: ${time}, reading: ${reading}`);\n    }\n  };\n};\n\nconnectWebSocket();\n\n\n//# sourceURL=webpack://piscope/./src/drawer.js?");

/***/ }),

/***/ "./src/fitter.js":
/*!***********************!*\
  !*** ./src/fitter.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Fitter: () => (/* binding */ Fitter)\n/* harmony export */ });\n/* harmony import */ var regression__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! regression */ \"./node_modules/regression/dist/regression.js\");\n/* harmony import */ var regression__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(regression__WEBPACK_IMPORTED_MODULE_0__);\n// Fit a line to the measured points.\n// This waits for the measured value to pass some threshold, then fits all the recent points\n// between two other threholds.\n// Each channel is treated independently.\n// This fits both +ve and -ve slopes.\n\n\n\nclass Fitter {\n  constructor(options) {\n    // Destructuring assignment with default values for the options parameter.\n    const {channel = 0, triggerHigh = 3000, triggerLow = 300, limitHigh = 2800, limitLow = 500, lookingForPositiveSlope = true, addError} = options;\n\n    // Assign each option to a property in this class.\n    this.channel = channel;\n    this.triggerHigh = triggerHigh;\n    this.triggerLow = triggerLow;\n    this.limitHigh = limitHigh;\n    this.limitLow = limitLow;\n    this.lookingForPositiveSlope = lookingForPositiveSlope;\n    this.data = [];\n    this.addError = addError;\n  }\n\n  fitLineIfTrigger(datum) {\n    const {time, reading} = datum; // Removed comment of destructuring time\n\n    // Check if the reading is within the limits to be added to data.\n    if (reading <= this.limitHigh && reading >= this.limitLow) {\n      this.data.push([time, reading]);\n    }\n\n    // Determine whether to trigger the line fitting process.\n    let trigger = false;\n    if (this.lookingForPositiveSlope && reading > this.triggerHigh) {\n      trigger = true;\n    } else if (!this.lookingForPositiveSlope && reading < this.triggerLow) {\n      trigger = true;\n    }\n\n    // If a trigger condition is met, fit the line and reset for next fitting cycle.\n    if (trigger) {\n      this.fit(this.data);\n      this.data = [];\n      this.lookingForPositiveSlope = !this.lookingForPositiveSlope;\n      return true;\n    }\n    return false;\n  }\n\n  // Fit a line to the provided data array.\n  fit(data) {\n    // Check if there is enough data to fit a line.\n    if (data.length < 2) {\n      throw new Error('Not enough data to fit a line');\n    }\n\n    // Use the linear regression function from the regression library.\n    const result = regression__WEBPACK_IMPORTED_MODULE_0___default().linear(data);\n    const [a, b] = result.equation;\n\n    // Calculate and report the error for each data point.\n    data.forEach(([time, reading]) => {\n      const expectedReading = a * time + b;\n      const error = reading - expectedReading;\n      if (this.addError) {\n        this.addError({channel: this.channel, time, error});\n      } else {\n        // Handle the case where addError is not provided or is not a function.\n        throw new Error('addError function is not defined or is not a function');\n      }\n    });\n\n    // Return the result of the regression.\n    return result;\n  }\n}\n\n// Export the Fitter class for use in other modules.\n\n\n\n//# sourceURL=webpack://piscope/./src/fitter.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _drawer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./drawer.js */ \"./src/drawer.js\");\n\n\n\n//# sourceURL=webpack://piscope/./src/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;